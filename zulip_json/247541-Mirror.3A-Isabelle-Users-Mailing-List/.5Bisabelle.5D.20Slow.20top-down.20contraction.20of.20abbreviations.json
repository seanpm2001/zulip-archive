[
    {
        "content": "<p>From: Fabian Immler &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHello everyone,</p>\n<p>We observed that pretty printing is slow when you have an abbreviation that is deeply nested in a term.<br>\nConsider e.g. the abbreviation <code>int == of_nat</code> in <code>iterate_bind</code>, where</p>\n<p>iterate_bind n = do {<br>\n      x ← Some x;<br>\n      ...;<br>\n      x ← Some x;<br>\n      Some (int x)<br>\n    }</p>\n<p>For <code>n = 1500</code> (a term size not uncommon in program verification), pretty printing takes about 60s.<br>\nThis is due to the fact that abbreviations are contracted top-down<br>\n(Proof_Context.standard_term_uncheck-&gt;contract_abbrevs-&gt;Pattern.rewrite_term_top).<br>\nBottom-up rewriting (Pattern.rewrite_term) takes less than a second (and obviously produces the same result in this case).</p>\n<p>Interestingly, <code>contract_abbrevs</code> used to do bottom-up rewriting prior to 5d2fe4e09354.<br>\nAnd while I am sure there must have been a reason for this change, the changeset unfortunately does not give a justification.</p>\n<p>Concrete explorations are below, with <code>contract_abbrevs'</code> as a parameterized variant of<br>\n<code>contract_abbrevs</code>.</p>\n<p>This is certainly a very delicate business, but does anyone have insights if or how this situation<br>\ncould be improved?</p>\n<p>Best wishes,<br>\nFabian</p>\n<p>—<br>\nFabian Immler<br>\n<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a> &lt;mailto:<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a>&gt;<br>\n SEG Formal Verification</p>\n<p>Scratch.thy:<br>\n=========</p>\n<p>theory Scratch<br>\n  imports<br>\n    Main<br>\n(* \"HOL-Library.Monad_Syntax\" *)<br>\nbegin</p>\n<p>ML ‹<br>\nfun iterate_bind 0 = Abs (\"x\", @{typ \"nat\"}, @{const Some(\"int\")} $ (@{term int} $ Bound 0))<br>\n  | iterate_bind i =<br>\n    Abs (\"x\", @{typ nat},<br>\n      @{const Option.bind(nat, int)} $ (@{const Some(nat)} $ Bound 0) $<br>\n      iterate_bind (i - 1))</p>\n<p>(* when including \"HOL-Library.Monad_Syntax\"<br>\niterate_bind 3 =  @{term \"λx. do {<br>\n    x ← Some x;<br>\n    x ← Some x;<br>\n    x ← Some x;<br>\n    Some (int x)<br>\n  }\"}<br>\n*)<br>\n›</p>\n<p>ML ‹<br>\n(* Pretty printing such a term with \"show_abbrevs\" is slow: *)<br>\nlocal<br>\nval ctxt = @{context}<br>\nval t = iterate_bind 1500<br>\nval ct = Thm.cterm_of ctxt t<br>\nval _ = timeap_msg \"show_abbrevs=true\"  (Syntax.string_of_term ctxt) t<br>\nval ctxt' = Config.put Proof_Context.show_abbrevs false ctxt<br>\nval _ = timeap_msg \"show_abbrevs=false\" (Syntax.string_of_term ctxt') t<br>\nin<br>\n  val t = t<br>\nend<br>\n›</p>\n<p>ML ‹<br>\nfun contract_abbrevs' ctxt rewrite_term t =<br>\n  let<br>\n    val thy = Proof_Context.theory_of ctxt;<br>\n    val consts = Proof_Context.consts_of ctxt;<br>\n    val abbrev = false;<br>\n    val retrieve = Consts.retrieve_abbrevs consts (print_mode_value () @ [\"\"]);<br>\n    fun match_abbrev u = <a href=\"http://Option.map\">Option.map</a> #1 (get_first (Pattern.match_rew thy u) (retrieve u));<br>\n  in<br>\n    if abbrev orelse not (Config.get ctxt show_abbrevs) orelse not (can Term.type_of t) then t<br>\n    else rewrite_term thy [] [match_abbrev] t<br>\n  end;<br>\n›<br>\nML ‹val t1 = timeap_msg \"top-down\" (contract_abbrevs' @{context} Pattern.rewrite_term_top) t›<br>\nML ‹val t2 = timeap_msg \"bot-up\"   (contract_abbrevs' @{context} Pattern.rewrite_term    ) t›<br>\nML ‹t1 = t2›</p>\n<p>end</p>",
        "id": 434138731,
        "sender_full_name": "Email Gateway",
        "timestamp": 1713455476
    }
]